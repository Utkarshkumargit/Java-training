152. Maximum Product Subarray////////////////////////////////////////

class Solution {
    public int maxProduct(int[] nums) {

      int maxProduct = Integer.MIN_VALUE;

    for( int i = 0; i <nums.length; i++ ){
        int currentProduct =  1;
        for(int j = i; j <nums.length; j++ ){
            currentProduct = currentProduct * nums[j];
            maxProduct = Mth.max(maxProduct , currentProduct);
        }
        
    }
        return maxProduct;
    }
  }
}

/////////////////////////optimal approach//////////////////////////////

class Solution {
    public int maxProduct(int[] nums) {
        int leftproduct = 1;
        int rightproduct = 1;

        int maxProduct = nums[0];

        for (int i = 0 ; i < nums.length ; i++){

            leftproduct = leftproduct == 0 ? 1 :leftproduct;
            rightproduct = rightproduct == 0 ? 1 :rightproduct;
            // prefixProduct 
            leftproduct = leftproduct * nums[i];
            //suffix product 
            rightproduct = rightproduct * nums[nums.length - i - 1];
            maxProduct = Math.max(maxProduct , Math.max(leftproduct ,rightproduct));

        } 
        return maxProduct;
    }
}




56.MERGE INTERVAL//////////////////////////////////////////////////////

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)-> Integer.compare(a[0],b[0]));

        List<int[]> merged = new ArrayList<>();
        
        int[] prev = intervals[0];

        for(int i = 1 ; i < intervals.length ; i++){
            int[] next = intervals[i];

            if(next[0] <= prev[1]){
                prev[1] = Math.max(prev[1], next[1]);

            }else{
                merged.add(prev);
                prev = next;
            }
        }
        merged.add(prev);
        return merged.toArray(new int[merged.size()][]);
    }
}

